from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
from sqlalchemy.orm import Session
from typing import List
from database.connection import get_db
from database.models.user import User
from routes.auth import get_current_user
from app.services.mod_service import mod_service
from app.services.minecraft import server_service

router = APIRouter(prefix="/api/servers/{server_name}/mods", tags=["Mods"])

@router.get("/")
@router.get("/")
async def list_mods(server_name: str, loader: str = None, current_user: User = Depends(get_current_user)):
    # Verify server exists
    if not server_service.get_process(server_name) and not os.path.exists(os.path.join(server_service.base_dir, server_name)):
         # Check DB if process not active? For now assume valid if folder exists or service knows it
         pass
         
    return await mod_service.get_installed_mods(server_name, loader)

@router.post("/upload")
async def upload_mod(
    server_name: str, 
    file: UploadFile = File(...), 
    current_user: User = Depends(get_current_user)
):
    try:
        if not file.filename.endswith(('.jar', '.zip', '.rar')):
            raise HTTPException(status_code=400, detail="Only .jar, .zip, and .rar files are allowed")
            
        result = await mod_service.upload_mod(server_name, file)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/search")
async def search_mods(payload: dict, current_user: User = Depends(get_current_user)):
    # payload: { query: str, version: str, loader: str }
    query = payload.get("query")
    version = payload.get("version")
    loader = payload.get("loader")
    
    if not query or not version:
         raise HTTPException(status_code=400, detail="Missing query or version")
         
    return await mod_service.search_mods(query, version, loader)

@router.post("/install")
async def install_mod_endpoint(server_name: str, payload: dict, current_user: User = Depends(get_current_user)):
    # payload: { project_id: str, version: str, loader: str }
    project_id = payload.get("project_id")
    version = payload.get("version")
    loader = payload.get("loader")
    
    # Get server to verify existence
    # ...
    
    try:
        await mod_service.install_mod(server_name, project_id, version, loader)
        return {"message": "Mod installed successfully"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/")
async def delete_multiple_mods(server_name: str, payload: dict, current_user: User = Depends(get_current_user)):
    # payload: { files: [str], loader: str }
    files = payload.get("files", [])
    loader = payload.get("loader")
    
    results = []
    for f in files:
        success = await mod_service.delete_mod(server_name, f, loader)
        results.append({"filename": f, "success": success})
        
    return results

@router.delete("/{filename}")
async def delete_mod(server_name: str, filename: str, loader: str = None, current_user: User = Depends(get_current_user)):
    success = await mod_service.delete_mod(server_name, filename, loader)
    if not success:
        raise HTTPException(status_code=404, detail="Mod not found")
    return {"message": "Mod deleted"}

import os
