from sqlalchemy.orm import Session
from app.services.minecraft import server_service
from typing import List, Optional, Dict, Any
from app.services.bitacora_service import BitacoraService
from database.models.server import Server

class ServerController:
    def get_all_servers(self, db: Session) -> List[Server]:
        servers = db.query(Server).all()
        for s in servers:
            self._inject_runtime_data(s)
        return servers

    def get_server(self, db: Session, name: str) -> Optional[Server]:
        server = db.query(Server).filter(Server.name == name).first()
        if server:
            self._inject_runtime_data(server)
        return server

    def _inject_runtime_data(self, server: Server):
        process = server_service.get_process(server.name)
        if process:
            # Stats dictionary: {"status": ..., "cpu": ..., "ram": ...}
            stats = process.get_stats()
            server.status = stats["status"]
            server.cpu_usage = stats["cpu"]
            server.ram_usage = stats["ram"]  # Use model field name
            server.current_players = stats.get("players", 0)  # Use model field name
            server.disk_usage = stats.get("disk", 0)
        else:
            server.status = "OFFLINE"
            server.cpu_usage = 0
            server.ram_usage = 0
            server.current_players = 0
            server.disk_usage = 0

    def get_server_stats(self, name: str):
        process = server_service.get_process(name)
        if process:
            return process.get_stats()
        return {"status": "OFFLINE", "cpu": 0, "ram": 0, "players": 0}

    def create_server(
        self, 
        db: Session, 
        name: str, 
        version: str, 
        ram_mb: int, 
        port: int, 
        online_mode: bool,
        mod_loader: str = "VANILLA",
        cpu_cores: float = 1.0,
        disk_mb: int = 2048,
        max_players: int = 20,
        motd: str = "A Minecraft Server"
    ):
        server = server_service.create_server(
            db, name, version, ram_mb, port, online_mode,
            mod_loader=mod_loader,
            cpu_cores=cpu_cores,
            disk_mb=disk_mb,
            max_players=max_players,
            motd=motd
        )
        if server:
             # Audit Log
             # Assuming we have a username context available or default to system/admin for now
             # In a real app, we'd pass the current_user to these controller methods
             BitacoraService.add_log(db, "ADMIN", "SERVER_CREATE", f"Created server {name} ({version})")
        return server

    def update_server(self, db: Session, name: str, data: Dict[str, Any]) -> Optional[Server]:
        server = db.query(Server).filter(Server.name == name).first()
        if not server:
            return None
        
        # Track if MasterBridge config changed
        mb_config_changed = any(key in data for key in ['masterbridge_enabled', 'masterbridge_ip', 'masterbridge_port'])
        
        for key, value in data.items():
            if value is not None and hasattr(server, key):
                setattr(server, key, value)
        
        db.commit()
        db.refresh(server)
        
        # Reload MasterBridge client if configuration changed
        if mb_config_changed:
            process = server_service.get_process(name)
            if process:
                if server.masterbridge_enabled:
                    from app.services.minecraft.masterbridge_client import MasterBridgeClient
                    process.masterbridge_client = MasterBridgeClient(
                        ip=server.masterbridge_ip or '127.0.0.1',
                        port=server.masterbridge_port or 8081
                    )
                    print(f"INFO: MasterBridge client updated for {name}")
                else:
                    process.masterbridge_client = None
                    print(f"INFO: MasterBridge client disabled for {name}")
        
        BitacoraService.add_log(db, "ADMIN", "SERVER_UPDATE", f"Updated server {name} with {list(data.keys())}")
        
        return server

    def delete_server(self, db: Session, name: str):
        server_service.delete_server(db, name)
        BitacoraService.add_log(db, "ADMIN", "SERVER_DELETE", f"Deleted server {name}")
        return True

    async def start_server(self, name: str):
        process = server_service.get_process(name)
        if process:
            await process.start()
            BitacoraService.add_log_background("ADMIN", "SERVER_START", f"Started server {name}")
            return True
        return False

    async def stop_server(self, name: str):
        process = server_service.get_process(name)
        if process:
            await process.stop()
            BitacoraService.add_log_background("ADMIN", "SERVER_STOP", f"Stopped server {name}")
            return True
        return False
    
    def kill_server(self, name: str):
        process = server_service.get_process(name)
        if process:
            process.kill()
            BitacoraService.add_log_background("ADMIN", "SERVER_KILL", f"Killed server {name}")
            return True
        return False

    async def restart_server(self, name: str):
        await self.stop_server(name)
        import asyncio
        await asyncio.sleep(2)
        await self.start_server(name)
        # Restart calls stop and start, so those will log individually. 
        # But we can add a specific restart log if we want explicit intent
        BitacoraService.add_log_background("ADMIN", "SERVER_RESTART", f"Triggered restart for {name}")
        return True

    async def send_command(self, name: str, command: str):
        process = server_service.get_process(name)
        if process:
            await process.write(command)
            BitacoraService.add_log_background("ADMIN", "SERVER_COMMAND", f"Sent command to {name}: {command}")
            return True
        return False
    
    def get_console_queue(self, name: str):
        process = server_service.get_process(name)
        if process:
            return process.subscribe_logs()
        return None
    
    async def export_server(self, db: Session, name: str) -> str:
        """Export a server as a ZIP file"""
        return await server_service.export_server(db, name)
    
    async def import_server(self, db: Session, file):
        """Import a server from a ZIP file"""
        return await server_service.import_server(db, file)
    
    # --- Player Management ---
    def get_online_players(self, name: str):
        """Get list of online players"""
        process = server_service.get_process(name)
        if process:
            return process.get_online_players()
        return []

    def get_recent_activity(self, name: str):
        """Get recent player activity (kicks, bans, etc)"""
        process = server_service.get_process(name)
        if process and hasattr(process, 'recent_activity'):
            return process.recent_activity
        return []
    
    async def kick_player(self, name: str, username: str):
        """Kick a player"""
        process = server_service.get_process(name)
        if process:
            return await process.kick_player(username)
        return False
    
    async def ban_user(self, name: str, username: str, reason: str = "Banned by admin", expires: str = "forever"):
        """Ban a player by username"""
        process = server_service.get_process(name)
        if process:
            return await process.ban_user(username, reason, expires)
        return False

    async def update_ban(self, name: str, username: str, reason: str = None, expires: str = None):
        """Update existing ban"""
        process = server_service.get_process(name)
        if process:
            return await process.update_ban(username, reason, expires)
        return False
    
    async def ban_ip(self, name: str, ip: str, reason: str = "Banned by admin", username: str = None):
        """Ban an IP address"""
        process = server_service.get_process(name)
        if process:
            return await process.ban_ip(ip, reason, username=username)
        return False
    
    def get_bans(self, name: str):
        """Get banned players and IPs"""
        process = server_service.get_process(name)
        if process:
            return process.get_bans()
        return {"players": [], "ips": []}
    
    async def unban_user(self, name: str, username: str):
        """Unban a player"""
        process = server_service.get_process(name)
        if process:
            return await process.unban_user(username)
        return False
    
    async def unban_ip(self, name: str, ip: str):
        """Unban an IP"""
        process = server_service.get_process(name)
        if process:
            return await process.unban_ip(ip)
        return False

    async def op_player(self, name: str, username: str):
        """Op a player"""
        process = server_service.get_process(name)
        if process:
            return await process.op_player(username)
        return False
    
    async def deop_player(self, name: str, username: str):
        """Deop a player"""
        process = server_service.get_process(name)
        if process:
            return await process.deop_player(username)
        return False
    
    async def send_chat_message(self, name: str, text: str, formatted: bool = False):
        """
        Send a chat message to the game
        Args:
            name: Server name
            text: Message text
            formatted: If True, sends as Admin with /tellraw, otherwise uses MasterBridge
        """
        process = server_service.get_process(name)
        if not process:
            return False
        
        if formatted:
            # Use /tellraw command for formatted admin message with yellow <Admin>
            # Escape quotes and backslashes in the message
            escaped_text = text.replace('\\', '\\\\').replace('"', '\\"')
            tellraw_command = f'tellraw @a [{{"text":"<","color":"yellow"}},{{"text":"Admin","color":"yellow"}},{{"text":"> ","color":"yellow"}},{{"text":"{escaped_text}","color":"white"}}]'
            await process.write(tellraw_command)
            return True
        else:
            # Use MasterBridge for regular messages
            return await process.send_chat_message(text)
    
    # --- MasterBridge Data Retrieval ---
    def get_mb_detailed_players(self, name: str):
        """Get detailed player data from MasterBridge API"""
        process = server_service.get_process(name)
        if process and process.masterbridge_client:
            return process.masterbridge_client.get_players()
        return None
    
    def get_mb_chat(self, name: str):
        """Get chat log from MasterBridge API"""
        process = server_service.get_process(name)
        if process and process.masterbridge_client:
            return process.masterbridge_client.get_chat()
        return None
    
    def get_mb_achievements(self, name: str):
        """Get player achievements from MasterBridge API"""
        process = server_service.get_process(name)
        if process and process.masterbridge_client:
            return process.masterbridge_client.get_achievements()
        return None
    
    def get_mb_full_state(self, name: str):
        """Get full server state from MasterBridge API"""
        process = server_service.get_process(name)
        if process and process.masterbridge_client:
            return process.masterbridge_client.get_full_state()
        return None

    # --- MasterBridge Actions ---
    async def trigger_event(self, name: str, data: dict):
        process = server_service.get_process(name)
        if process:
            return await process.trigger_event(data)
        return False

    async def trigger_cinematic(self, name: str, type_name: str, target: str, difficulty: int):
        process = server_service.get_process(name)
        if process:
            return await process.trigger_cinematic(type_name, target, difficulty)
        return False

    async def trigger_paranoia(self, name: str, target: str, duration: int):
        process = server_service.get_process(name)
        if process:
            return await process.trigger_paranoia(target, duration)
        return False

    async def trigger_special_event(self, name: str, event_type: str, target: str):
        process = server_service.get_process(name)
        if process:
            return await process.trigger_special_event(event_type, target)
        return False

    # --- Additional MasterBridge Data Methods ---
    def get_mb_chat_log(self, name: str):
        """Get complete chat log from MasterBridge"""
        process = server_service.get_process(name)
        if process and process.masterbridge_client:
            return process.masterbridge_client.get_chat_log()
        return None

    def get_mb_online_players_detailed(self, name: str):
        """Get detailed online players info from MasterBridge"""
        process = server_service.get_process(name)
        if process and process.masterbridge_client:
            return process.masterbridge_client.get_online_players_detailed()
        return None

    def get_mb_server_status(self, name: str):
        """Get server status from MasterBridge"""
        process = server_service.get_process(name)
        if process and process.masterbridge_client:
            return process.masterbridge_client.get_server_status()
        return None

    def get_mb_active_events(self, name: str):
        """Get active events from MasterBridge"""
        process = server_service.get_process(name)
        if process and process.masterbridge_client:
            return process.masterbridge_client.get_active_events()
        return None

    def get_mb_resource_pack(self, name: str):
        """Download resource pack from MasterBridge"""
        process = server_service.get_process(name)
        if process and process.masterbridge_client:
            return process.masterbridge_client.download_resource_pack()
        return None


