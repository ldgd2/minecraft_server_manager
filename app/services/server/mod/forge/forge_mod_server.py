import os
import requests
import json
import re

class ForgeModManager:
    """
    Generic Mod Manager for Forge, Fabric, Quilt, etc. using Modrinth API.
    Despite the name, it handles any loader supported by Modrinth.
    """
    def __init__(self, base_path="servers"):
        self.base_url = "https://api.modrinth.com/v2"
        self.base_path = base_path
        self.headers = {
            'User-Agent': 'MinecraftServerManager/1.0 (internal)' # Modrinth requires a descriptive UA
        }

    def buscar_mods(self, query=None, version=None, sort="relevance", loader="forge"):
        """
        Search for mods on Modrinth filtering by loader and version.
        """
        endpoint = f"{self.base_url}/search"
        
        # Facets: Strict filtering
        # We want: Categories = Loader AND (if version exists) Version = X.X.X
        # Note: Loader facet needs to be lowercase, e.g., "categories:forge" or "categories:fabric"
        loader_facet = f"categories:{loader.lower()}" if loader else "categories:forge"
        
        facets = [[loader_facet]]
        if version:
            facets.append([f"versions:{version}"])
            
        params = {
            "query": query if query else "",
            "facets": json.dumps(facets),
            "limit": 20
        }

        # Mapping sort types
        if sort == "downloads": params["index"] = "downloads"
        elif sort == "newest": params["index"] = "newest"
        elif sort == "updated": params["index"] = "updated"
        else: params["index"] = "relevance"

        try:
            print(f"[*] Searching Modrinth: {params}")
            r = requests.get(endpoint, headers=self.headers, params=params)
            r.raise_for_status()
            data = r.json()
            
            resultados = []
            for hit in data.get('hits', []):
                resultados.append({
                    'author': hit.get('author'),
                    'name': hit.get('title'),
                    'slug': hit.get('slug'), # Unique ID for download
                    'description': hit.get('description'),
                    'url': f"https://modrinth.com/mod/{hit.get('slug')}",
                    'icon': hit.get('icon_url') or "https://via.placeholder.com/64?text=Mod",
                    'loader': loader
                })
            return resultados
        except Exception as e:
            print(f"[!] Modrinth API Error: {e}")
            return []

    def obtener_info_descarga(self, slug, version_mc, loader="forge"):
        """
        Gets the direct download link for the compatible JAR.
        """
        if not version_mc:
            return None

        # Endpoint: List project versions
        endpoint = f"{self.base_url}/project/{slug}/version"
        
        # Modrinth expects loaders as a JSON list, e.g. ["forge"]
        loader_param = [loader.lower()] if loader else ["forge"]
        
        params = {
            "loaders": json.dumps(loader_param),
            "game_versions": json.dumps([version_mc])
        }

        try:
            print(f"[*] Searching compatible version for {slug} on {version_mc} ({loader})...")
            r = requests.get(endpoint, headers=self.headers, params=params)
            r.raise_for_status()
            versions = r.json()

            if not versions:
                return None
            
            # Take the first one (most recent compatible)
            target_version = versions[0]
            
            # Find primary .jar file
            primary_file = next((f for f in target_version['files'] if f['primary']), target_version['files'][0])
            
            return {
                'url': primary_file['url'],
                'filename': primary_file['filename'],
                'version_name': target_version['name']
            }

        except Exception as e:
            print(f"[!] Error getting download info: {e}")
            return None

    def instalar_mod(self, server_name, download_info):
        # FOLDER: mods (Different from plugins)
        path = os.path.join(self.base_path, server_name, "mods")
        os.makedirs(path, exist_ok=True)
        
        file_path = os.path.join(path, download_info['filename'])
        
        try:
            print(f"[*] Downloading to: {file_path}")
            r = requests.get(download_info['url'], stream=True, headers=self.headers)
            r.raise_for_status()
            
            with open(file_path, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)
            return True, file_path
        except Exception as e:
            return False, str(e)

    def listar_mods_instalados(self, server_name):
        server_path = os.path.join(self.base_path, server_name)
        if not os.path.exists(server_path): return []
            
        mods_list = []
        
        # 1. Scan 'mods' folder
        mods_path = os.path.join(server_path, "mods")
        if os.path.exists(mods_path):
            for root, dirs, files in os.walk(mods_path):
                for f in files:
                    if f.endswith('.jar'):
                        full_path = os.path.join(root, f)
                        rel_path = os.path.relpath(full_path, server_path).replace("\\", "/")
                        size_mb = os.path.getsize(full_path) / (1024 * 1024)
                        
                        mods_list.append({
                            'filename': rel_path,
                            'name_only': f,
                            'location': 'mods',
                            'size': f"{size_mb:.2f} MB"
                        })
        return mods_list

    def eliminar_mod(self, server_name, rel_path):
        if '..' in rel_path: return False, "Invalid path."

        server_path = os.path.abspath(os.path.join(self.base_path, server_name))
        file_path = os.path.abspath(os.path.join(server_path, rel_path))

        if not file_path.startswith(server_path): return False, "Access denied."
        if not os.path.exists(file_path): return False, "File not found."

        try:
            os.remove(file_path)
            # NOTE: In Forge/Fabric, configs are in /config/, usually not in /mods/ModName/.
            # Deleting configs automatically is risky as names don't matches often.
            # We stick to deleting the .jar for safety.
            return True, f"Deleted: {os.path.basename(rel_path)}"
        except Exception as e:
            return False, str(e)
